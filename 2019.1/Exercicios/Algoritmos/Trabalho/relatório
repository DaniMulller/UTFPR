Nesse trabalho foi possível observar os diferentes tipos de ordenação, seus tempos de execução, seus piores casos e concluir qual algoritmo é melhor em cada situação.

No primeiro teste foi utilizado um vetor de 2500 elementos, o proximo de 5000, e depois de 7500, até um vetor limite de 50000 elementos, no total 20 vetores diferentes para cada caso.

O primeiro caso envolveu ordenar um vetor aleatório, nesse caso os algoritmos de ordenação elementares(Selection, Insertion, Bubble) praticamente tiverem a complexidade constante de n². Já os algoritmos mais eficientes de ordenação(Quick,Merge) manteram a complexidade em nlog(n) basicamente em todos os testes.

No caso de um vetor crescente, alguns algorimos elementares foram mais eficientes que os mais complexos. Bubble e Insertion tiveram o tempo nulo em todos os casos independente do tamanho do vetor, isso porque o melhor caso para esses algoritmos é esse, já o Seletion teve um desemepenho um pouco pior. Mas o Quick teve um desempenho muito ruim nesse caso, pois é um dos piores casos pra ele, tornando a complexidade n².

Em um vetor decrescente, os algorimos elementares tiverem um desempenho ruim de n². O Merge independe de como o vetor está ordenado pois sempre fará suas divisões com complexidade nlog(n). E o Quick foi ruim novamente pois é mais um pior caso, juntamente com o vetor crescente, tornando-o n² nessa situação.

Conclusões:
Em vetores aleatórios, o Quick é melhor que qualquer um dos outros, com um desempenho médio de nlog(n) e na prática,mais rápido que o Merge. Já os elementares tem na média o desempenho de n².

Num vetor crescente, os campeões são os elementares com a complexidade de n. Já o Quick fica em último lugar por ser seu pior caso.

Já em um vetor decrescente, o vencedor é o Merge que mantém constante a sua complexidade de nlog(n) em qualquer caso, já os outros todos tem a complexidade de n².  
